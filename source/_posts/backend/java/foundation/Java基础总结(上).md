---
title: Java基础总结(上)
link: backend-java-foundation-Java基础总结(上)
catalog: true
lang: cn
date: 2022-07-31 01:02:56 
tags:
- 后端
- Java基础
categories:
- [后端,Java,基础]
---
# Java基础概念与常识

## Java 语言有哪些特点？
1. 简单易学
2. 面向对象(封装，继承，多态，抽象)
3. 跨平台(Java虚拟机实现平台的无关性)
4. 安全性
5. 可移植性(可以在不同环境中移植和复用)
6. 高性能(JIT，GC，并发)
7. 支持多线程(可以执行多个任务的处理)
8. 支持网络编程(Java编写网络编程很方便，Java本身就是简化网络编程设计的)

## JVM VS JDK VS JRE

### JVM
JVM 是 Java 语言最核心的组成部分之一，它是 Java 语言平台的实现基础。JVM 负责将 Java 的源代码编译成字节码，并在运行时将字节码解释成机器码来执行程序。由于 JVM 的存在， Java 程序可以在不同操作系统和硬件平台上运行。JVM 还包括了垃圾回收器等内存管理机制， 以及类加载、安全等各种运行时环境相关的功能。

**JVM 不只是只有以一种**，而且在 Java 技术的发展过程中，出现了许多不同的 JVM 实现，**只要满足 JVM 的规范不管是每个公司，组织，甚至是个人都可以开发自己专属的 JVM**，目前，业界使用最广泛的 JVM 实现是 HotSpot VM，也仅仅是 JVM 规范的一种实现而已。

除了我们平常最常用的 HotSpot VM 外，还有 OpenJ9，GraalVM，Azul Zing，JRockit等等，感兴趣的可以去 WIKi 上看一下。
你可以在 [Java SE Specifications](https://docs.oracle.com/javase/specs/index.html) 上面找到各种版本的 JDK 对应的 JVM 规范。

**拓展一下：**
Write Once， Run Anywhere (一次编写，随处运行) 这句宣传口号，真的是经典啊!直到今天依然还是有很多人觉得跨平台是 Java 语言的最大优势， 其实跨平台都已经不是 Java 的最大卖点了，以及各种的 JDK 新特性 也都不是。目前市面上的虚拟化已经很成熟了比如 Docker 的虚拟化就很容易的实现了跨平台，在我看来 Java 强的是在有庞大的社区以及完善的平台。

### JDK 和 JRE

JDK（Java Development Kit）是Java开发工具，包含了Java编译器（javac）、 Java 虚拟机（JVM）以及其他用于开发Java程序的工具和库。
JDK 提供了完整的 Java 开发环境，可以方便地进行 Java 程序的开发、编译、调试和部署。

JRE（Java Runtime Environment）是Java运行环境，包含了 Java 虚拟机（JVM）和 Java 核心类库。
JRE 只提供了Java程序的运行环境，没有提供 Java 程序的开发和编译等功能。

也就是说，JRE 是 Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。而 JDK 则包含了 JRE，同时还包括了 Javac，Javadoc，jconsole，Javap等工具，可以用于 Java 应用程序开发和调试。如果还需要进行 Java 编程工作，比如编写和编译 Java 代码程序，使用 Java API 文档等，就需要安装 JDK。而对于某些需要使用 Java 特性的应用程序，如 使用反射，也需要 JDk 来进行编译和运行 Java 代码。因此，即使不但算进行 Java 应用程序的开发工作，也有可能需要安装 JDK。

## 什么是字节码？

在 Java 中，JVM 可以被解释执行的代码就叫做 字节码 (扩展文件的后缀为.class文件)。

### 采用字节码的好处是什么？

1. 跨平台性：Java编译器将Java源代码编译为字节码文件，而不是机器码。这种中间码具有平台无关性，可以在任何支持Java虚拟机（JVM）的硬件和操作系统上运行，从而实现跨平台性。

2. 安全性：由于Java字节码不能直接执行，只能由JVM解释执行，因此可以防止恶意代码对系统的直接攻击。Java字节码通过类加载器加载后，会经过严格的验证、准备和解析等过程，确保其不会损害系统或者其他程序的安全性。

3. 可移植性：由于Java字节码是平台无关的，因此Java应用程序可以轻松地在不同平台之间进行移植和扩展。只需要在新的平台上安装JVM，就可以直接运行Java字节码，而无需对源代码进行修改或重新编译。

4. 加载速度快：由于Java字节码是已编译的二进制代码，在加载时不需要进行重新编译，只需要进行校验、准备和解析等操作，并通过即时编译技术（JIT）将热点代码优化成机器码，从而使得Java程序的启动时间更快，响应更迅速。

5. 动态性：Java字节码可以基于运行时环境动态地加载和卸载，从而实现动态扩展和热部署。这种动态性使得Java应用程序更加灵活和可维护。

综上所述，采用字节码作为中间层的好处主要包括跨平台性、安全性、可移植性、加载速度快和动态性等方面，这些优势使得Java成为一种广泛使用的编程语言。

**Java 程序从源代码到运行的过程中如下图所示：**

我们需要格外注意的是 .class->机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。 而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)， 所以后面引进了，JIT（just-in-time compilation）,JIT是一种动态编译技术，它可以将Java字节码在运行时动态地编译成机器码，并将其存放在本地缓存中，下次可以直接使用，而我们知道，机器码的运行效率肯定是高于 Java 解释器的，这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。

HotSpot JIT编译器采用了惰性评估（Lazy Evaluation）的做法，它只针对那些被频繁执行的代码进行即时编译，以提高Java应用程序的性能和响应速度。由于执行次数较少的代码往往不会生成机器码，因此JIT编译器能够避免不必要的编译开销，减少内存占用和启动时间。 除了JIT编译器，JDK 9还引入了一种新的编译模式——AOT（Ahead of Time Compilation）。AOT是指将Java字节码在构建时直接编译成机器码，并打包为本地可执行文件，从而实现更快、更安全、更可预测的运行效果。与JIT相比，AOT具有预编译、静态编译等优势，可以避免JIT预热等方面的开销，但因为不能动态地根据环境进行优化，所以可能会牺牲一些性能和灵活性。 JDK也支持分层编译和AOT协作使用。分层编译是一种新的JIT编译器优化技术，可以将代码分解成多个层级，按需进行编译，从而兼顾启动速度和运行效率。与AOT相结合，可以使得Java应用程序在启动时尽可能地快速响应，同时又能在运行时获得更高的性能和更好的体验。 HotSpot JIT编译器采用惰性评估的方式，只编译热点代码以提高性能；JDK 9引入了AOT编译模式，可以避免JIT预热等开销；分层编译和AOT可以协同使用，以兼顾启动速度和运行效率。

JDK、JRE、JVM、JIT 这四者的关系如下图所示。

下面这张图是 JVM 的大致结构模型。

## 为什么不全部使用 AOT 呢？

虽然AOT编译能够提供更快、更安全、更可预测的运行效果，但由于不能动态优化、需要为每个平台生成不同的机器码、会增加应用程序的体积和部署难度等问题，因此并不适合所有场景，不能完全替代JIT编译器。

## 为什么说 Java 语言“编译与解释并存”？

我们可以将高级编程语言按照程序的执行方式分为两种：
编译型语言是指在程序运行之前先将源代码编译成机器码，然后执行机器码。编译型语言的优点是程序运行速度快，但缺点是需要为不同的平台编写不同的机器码，因此不具有跨平台的优势。一些常见的编译型语言包括C、C++、Pascal等。
解释型语言是指在程序执行时逐行逐句地解释执行源代码。解释型语言的优点是具有跨平台的优势，但缺点是程序运行速度相比编译型语言较慢。一些常见的解释型语言包括Python、Ruby、JavaScript等。

根据维基百科介绍：
> 为了改善编译语言的效率而发展出的即时编译open in new window技术，已经缩小了这两种语言间的差距。这种技术混合了编译语言与解释型语言的优点，它像编译语言一样，先把程序源代码编译成字节码open in new window。到执行期时，再将字节码直译，之后执行。Javaopen in new window与LLVMopen in new window是这种技术的代表产物。相关阅读：基本功 | Java 即时编译器原理解析及实践

Java 语言采用“编译与解释并存”的方式，先将源代码先编译成字节码，再由 Java 虚拟机解释执行。

## Oracle JDK vs OpenJDK

可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle JDK 和 OpenJDK 之间是否存在重大差异？

Oracle JDK和OpenJDK都是Java Development Kit（JDK）的不同实现。

Oracle JDK是由Oracle公司开发和维护的Java开发工具包，提供了完整的Java SE规范和一些商业特性。它包括Java Runtime Environment（JRE）和Java Development Kit（JDK），可以用于开发和部署Java应用程序。Oracle JDK是以商业许可证和GPLv2许可证发布的，对于商业用途需要购买许可证。

OpenJDK是一个更加开放和自由的替代品，是一个由全球各地的开发者共同维护的开源Java开发工具包。它也遵循Java SE规范，并包含JRE和JDK，可用于开发和部署Java应用程序。OpenJDK是根据GPLv2许可证发布的，使用OpenJDK需要遵循该许可证的条款。

两者的区别在于Oracle JDK包含了一些商业特性，而OpenJDK是纯开源的。Oracle JDK有更精细的社区支持，可以提供更好的文档和技术支持，同时也有更好的兼容性和稳定性。相比之下，OpenJDK更加灵活且性价比高，适合那些希望自定义和优化Java环境的用户。

### Oracle JDK 和 OpenJDK 如何选择？

选择Oracle JDK还是OpenJDK主要取决于个人或组织的需求和使用情况。

如果您需要Oracle JDK中独有的商业特性和技术支持，并且愿意为此支付相应的费用，则可以选择Oracle JDK。

如果您更加注重开源和灵活性，并且希望使用免费且开放的Java开发工具包，那么您可以选择OpenJDK。OpenJDK可以自由修改和分发，并且有一个由全球开发者维护的庞大社区，提供高质量的文档和技术支持。

此外，考虑到一些版本的Oracle JDK中可能出现许可证问题，如果您想要避免与许可证相关的风险，那么OpenJDK也是一个很好的选择。

**拓展一下：**
BCL 协议（Oracle Binary Code License Agreement）：可以使用 JDK（支持商用），允许用户下载、复制、使用和部署Oracle二进制代码产品，但它通常不允许用户修改Oracle代码。除非特别授权，否则这些二进制文件通常不能与其他软件一起分发或出售。
OTN 协议（Oracle Technology Network License Agreement）：11 及之后新发布的 JDK 用的都是这个协议，可以自己私下用，但是商用需要付费。

# 基本语法

## 注释有哪几种形式？

在 Java 中，注释可以分为三种形式：单行注释、多行注释和文档注释。

1. 单行注释

单行注释是以双斜线 " // " 开头的注释，用于单独一行的注释或在代码行末添加注释。例如：

```java
int age = 18; // 定义变量 age 并初始化为 18 岁
```

2. 多行注释

多行注释是以 " /* " 开头，以 " */ " 结尾的注释，可以跨越多行，也可用于注释掉程序块。例如：

```java
/*
 * 这是一个示例程序，用于演示多行注释的用法。
 * 以下语句用于打印输出一条消息。
 */
System.out.println("Hello, world!");
```

3. 文档注释

文档注释是以 " /** " 开头，以 " */ " 结尾的注释，用于描述类、接口、方法和字段的作用、参数、返回值等详细信息，可通过 javadoc 工具生成 API 文档。例如：

```java
/**
 * 这个类用于表示一个人，包含姓名和年龄两个属性。
 */
public class Person {
    private String name; // 姓名
    private int age;     // 年龄

    /**
     * 构造方法。
     *
     * @param name 姓名
     * @param age  年龄
     */
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    /**
     * 获取姓名。
     *
     * @return 姓名
     */
    public String getName() {
        return name;
    }

    /**
     * 获取年龄。
     *
     * @return 年龄
     */
    public int getAge() {
        return age;
    }
}
```

总结一下，Java 中有三种注释形式：单行注释、多行注释和文档注释。单行注释以双斜线开头，多行注释以 " /* " 开头，文档注释以 " /** " 开头，每种注释形式都有其特定的应用场景。

## 为什么要写注释？

在编写代码时，注释是非常重要的，它能够为代码提供一些额外的信息和标记，帮助其他开发人员或未来的自己更好地理解代码。以下是写注释的一些原因：

1. 提高代码可读性

注释能够使代码更易于阅读和理解。通过注释，其他开发人员能够更快速地了解代码实现的逻辑和功能，从而更容易维护和升级代码。

2. 方便代码维护

随着时间的推移，代码可能需要进行多次修改和更新。写好注释可以帮助开发人员更快速地进行代码维护和升级，也能够减少出现 Bug 的可能性。

3. 帮助调试

当出现问题时，有注释的代码更方便调试，开发人员能够更快速地定位到代码问题所在，并作出修复。

4. 方便团队协作

在团队协作中，注释可以帮助团队成员更好地理解代码的意图和实现方式，减少代码之间的沟通成本。

总之，写注释是一种好的编程习惯，可以让代码更清晰、易读、易于维护、易于调试和便于团队协作。因此，在编写代码时，建议养成书写注释的好习惯。

## 标识符和关键字的区别是什么？

在 Java 中，标识符和关键字是两个不同的概念，它们具有不同的含义和用途。

1. 标识符

标识符是程序中用来标识变量、方法、类名、接口名等各种实体的名称，由字母、数字、下划线和美元符号组成。在 Java 中，标识符有以下规则：

- 标识符必须以字母、下划线或美元符号开头。
- 标识符不能以数字开头。
- 标识符只能由字母、数字、下划线和美元符号组成。
- 标识符大小写敏感，即大写字母和小写字母是不同的标识符。

例如，在 Java 中，变量名、方法名、类名等都是标识符，如下所示：

```java
int age = 18;   // age 是一个变量名，是一个标识符
public void printName() {  // printName 是一个方法名，也是一个标识符
    // 方法实现
}
public class Person {      // Person 是一个类名，也是一个标识符
    // 类实现
}
```

2. 关键字

关键字是 Java 中预定义的具有特殊意义的单词或保留字，它们被用于描述语言本身的结构和语法，不能用于自定义标识符的命名。Java 中有 50 多个关键字，如下所示：

```java
abstract    assert      boolean     break       byte
case        catch       char        class       const
continue    default     do          double      else
enum        extends     final       finally     float
for         goto        if          implements  import
instanceof  int         interface   long        native
new         package     private     protected   public
return      short       static      strictfp    super
switch      synchronized    this    throw       throws
transient   try         void        volatile    while
```

因为关键字是 Java 语言中内置的特殊单词，在程序中不能用作标识符的名称，否则会产生编译错误。例如，以下代码尝试用关键字 `class` 声明一个变量名，会导致编译错误：

```java
int class = 10; // 错误：class 是一个关键字，不能用作变量名
```

因此，开发者在编写代码时应该避免使用关键字作为标识符的名称，以免出现编译错误。

## Java 语言关键字有哪些？

Java 语言中有 53 个关键字：

| 关键字 | 描述 |
| :-- | :-- |
| abstract | 声明抽象类或抽象方法 |
| assert | 在调试过程中，进行断言判断 |
| boolean | 声明布尔类型变量 |
| break | 跳出循环 |
| byte | 声明字节类型变量 |
| case | 在 switch 语句中匹配一个值 |
| catch | 捕获异常 |
| char | 声明字符类型变量 |
| class | 声明一个类 |
| const | 不再使用，被 final 关键字代替 |
| continue | 结束本次循环，继续下一次循环 |
| default | switch 语句中的默认情况 |
| do | 定义 do-while 循环 |
| double | 声明双精度浮点数类型变量 |
| else | if 语句的可选部分 |
| enum | 声明枚举类型 |
| extends | 声明一个类是另一个类的子类 |
| final | 声明不可改变的常量或类或方法不能被重载 |
| finally | 有异常时一定会执行的代码块 |
| float | 声明单精度浮点数类型变量 |
| for | 定义 for 循环 |
| goto | 不再使用，Java 中没有实现 |
| if | 定义 if 条件语句 |
| implements | 实现接口 |
| import | 引入其他包中的类 |
| instanceof | 测试对象是否为一个类的实例 |
| int | 声明整型变量 |
| interface | 声明一个接口 |
| long | 声明长整型变量 |
| native | 指示一个方法是用非 Java 语言实现的 |
| new | 创建一个新对象 |
| package | 声明一个包 |
| private | 声明私有属性、方法或类 |
| protected | 声明受保护属性、方法或类 |
| public | 声明公共属性、方法或类 |
| return | 定义方法返回值 |
| short | 声明短整型变量 |
| static | 声明静态属性、方法或类 |
| strictfp | 精确浮点计算 |
| super | 对象的超类 |
| switch | 定义 switch 语句 |
| synchronized | 同步方法 |
| this | 当前对象 |
| throw | 抛出异常 |
| throws | 声明异常 |
| transient | 对象序列化 |
| try | 定义一个将被激活的异常处理区块 |
| void | 声明 void 类型，无返回值 |
| volatile | 对象的 volatile 变量可以被随时修改 |
| while | 定义 while 循环 |

除此之外，Java 还有三个保留字：

- goto：暂时不再使用，但是是保留字。
- const：同样被 final 关键字代替。
- null：表示空对象，不是关键字或保留字，但在 Java 中却具有特殊的语义和使用。

## 自增自减运算符

在 Java 中，自增自减运算符是一种特殊的运算符，用于对变量进行加 1 或减 1 的操作。Java 中有两个自增自减运算符：

- ++：自增运算符，将变量加 1。
- --：自减运算符，将变量减 1。

这两个运算符都可以用于前缀和后缀运算。

- 前缀运算：先进行自增或自减操作，再使用变量的值。
- 后缀运算：先使用变量的值，再进行自增或自减操作。

例如，假设有一个整型变量 `count`，其初始值为 5，那么在进行前缀和后缀运算时，变量值的变化如下：

```java
int count = 5;

// 前缀自增运算
++count;    // count 的值变为 6
// 后缀自增运算
count++;   // count 的值变为 7

// 前缀自减运算
--count;    // count 的值变为 6
// 后缀自减运算
count--;   // count 的值变为 5
```

需要注意的是，自增自减运算符既可以用于整型类型的变量，也可以用于浮点型、字符型和短整型等其他数据类型的变量。但是，在使用这些运算符时需要注意数据类型的兼容性，以避免出现类型转换错误和运算符重载问题。

## 移位运算符

在 Java 中，移位运算符是一类比较特殊的运算符，它用于对二进制数据进行左移和右移操作。Java 中共有三种移位运算符：
- **<<**：左移运算符，将一个数的二进制表示向左移动指定的位数，低位补零。
- **>>**：带符号右移运算符，将一个数的二进制表示向右移动指定的位数，高位补符号位（即原来的符号位）。
- **>>>**：无符号右移运算符，将一个数的二进制表示向右移动指定的位数，高位补 0。

这些运算符的使用方法如下：

```java
int a = 60;     // 十进制数 60，二进制表示为 0011 1100
int b = -13;    // 十进制负数 -13，二进制表示为 1111 0011

int c = a << 2; // 将 a 向左移动 2 位，结果为 240
int d = b >> 2; // 将 b 向右移动 2 位，结果为 -4
int e = b >>> 2;// 将 b 向右移动 2 位，无符号高位补 0，结果为 1073741820
```

需要注意的是，移位运算符只能用于整型类型的变量，且移动的位数必须是非负整数。在进行移位操作时，需要考虑数据类型的符号位和长度，避免出现意外的结果。此外，左移运算符也可以用于实现二进制数据的倍增、二进制快速幂等高效计算。

## continue、break 和 return 的区别是什么？

在 Java 中，continue、break 和 return 是三种控制流程的关键字，它们的主要区别如下：

1. continue：
   在循环语句中遇到 continue 关键字时，会立即跳过当前循环块中剩余的语句，继续执行下一次循环。continue 主要用于加速循环的执行，例如在循环过程中跳过某些不需要处理的情况。

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        continue;
    }
    System.out.println(i);
}

// 输出结果：0 1 2 3 4 6 7 8 9
```

2. break：
   在循环语句或 switch 语句中遇到 break 关键字时，会立即中断当前循环或 switch 语句，并跳出整个语句块。break 主要用于提前结束循环或 switch 语句的执行。

```java
for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    System.out.println(i);
}

// 输出结果：0 1 2 3 4
```

3. return：
   在方法中遇到 return 关键字时，会立即结束当前方法的执行并返回指定的值（或者不返回任何值）。return 主要用于从方法中返回结果或提前结束方法的执行。

```java
public static int add(int a, int b) {
    return a + b;
}

int sum = add(2, 3);
System.out.println(sum);

// 输出结果：5
```

需要注意的是，这些关键字的使用都应该慎重，不合适的使用可能会导致程序逻辑出错。特别是在嵌套循环中的使用情况，需要特别警惕循环控制条件和循环变量的变化，以避免出现死循环或者逻辑错误。

# 基本数据类型

## Java 中的几种基本数据类型了解么？

Java 的基本数据类型包括以下 8 种：

1. byte（字节型）：占用 1 个字节，取值范围是 -128 到 127。
2. short（短整型）：占用 2 个字节，取值范围是 -32768 到 32767。
3. int（整型）：占用 4 个字节，取值范围是 -2147483648 到 2147483647。
4. long（长整型）：占用 8 个字节，取值范围是 -9223372036854775808 到 9223372036854775807。
5. float（单精度浮点型）：占用 4 个字节，可表示小数，精度为约 7 位有效数字。
6. double（双精度浮点型）：占用 8 个字节，可表示小数，精度为约 15 位有效数字。
7. char（字符型）：占用 2 个字节，用于表示单个 Unicode 字符。
8. boolean（布尔型）：占用 1 个字节，取值只有 true 和 false。

其中，整数型（包括 byte、short、int、long）和浮点型（包括 float、double）分别可以存储整数和小数。字符型表示一个 Unicode 字符，而布尔型只能表示 true 或 false 两种值。

在使用这些数据类型时，需要根据实际需求，选择合适的类型。需要注意的是，对于浮点数的计算，由于计算机的精度有限，可能出现精度误差的情况。在对浮点数进行比较时，应该使用约等于符号「≈」，而非严格相等符号「==」来进行判断。

## 基本类型和包装类型的区别？

Java 中基本数据类型和包装类型的区别可以总结为以下 4 点：

1. 存储位置：基本数据类型是存储在栈中的，包装类型是存储在堆中的。

2. 初始值：基本数据类型的初始值是 0 或 false（布尔型），而包装类型的初始值是 null。

3. 装箱和拆箱：将基本数据类型转换为对应的包装类型的过程称为「装箱」，而将包装类型转换为对应的基本数据类型的过程称为「拆箱」。可以通过构造器、静态方法或自动装箱和拆箱来实现这两个概念。

4. 支持方法：包装类型相比基本数据类型支持更多的方法，例如 Integer 类型的 parseInt() 方法和 toString() 方法等，这使得包装类型在一些复杂的场景下更加灵活。

例如，将 int 类型的数据装箱为 Integer 类型的数据：

```java
int num = 10;
Integer integer = new Integer(num); // 构造器装箱
Integer integer1 = Integer.valueOf(num); // 静态方法装箱
Integer integer2 = num; // 自动装箱
```

将 Integer 类型的数据拆箱为 int 类型的数据：

```java
Integer integer = new Integer(10);
int num = integer.intValue(); // 调用 intValue() 方法进行拆箱
int num1 = Integer.parseInt(integer.toString()); // 先调用 toString() 方法再调用 parseInt() 方法进行拆箱
int num2 = integer; // 自动拆箱
```

需要注意的是，在使用包装类型时，要注意空指针异常的问题。因为包装类型的初始值是 null，如果没有对其进行赋值就直接使用，就可能引发 NullPointerException 异常。

## 包装类型的缓存机制了解么？

Java 中有 8 个基本数据类型对应的包装类型，这些包装类型都实现了常量池技术（也称缓存机制），即在某个固定范围内，每次使用相同的值创建对象时，实际上返回的是同一个对象的引用，而不是每次都新创建一个对象。

以 Integer 类型为例，整数在 -128 到 127 之间的 Integer 对象会被缓存，超出这个范围的则不会缓存。这是因为大部分 Java 应用程序都会使用到小于 127 的数字，节省了很多对象的创建和回收，提高了程序的性能。其他的包装类型类似。

下面是一个简单的示例：

```java
Integer a = 10;
Integer b = 10;
System.out.println(a == b); // 输出 true

Integer c = 200;
Integer d = 200;
System.out.println(c == d); // 输出 false
```

在上面的示例中，变量 a 和 b 都是 Integer 类型的，且都赋值为 10。由于 10 在缓存范围内，因此 a 和 b 引用的是同一个对象，比较结果为 true。而变量 c 和 d 赋值为 200，超出了缓存范围，因此 c 和 d 引用的是不同的对象，比较结果为 false。

需要注意的是，虽然自动装箱和手动装箱的结果可能不同，但是如果使用 valueOf() 方法装箱，返回的对象肯定是缓存中的对象。同时，通过 equals() 方法比较包装类型的值时，会自动进行拆箱操作，因此比较结果是符合预期的。

## 自动装箱与拆箱了解吗？原理是什么？

自动装箱和拆箱是 Java 5 中新增的语言特性，可以方便地在基本数据类型和对应的包装类型之间进行转换，而无需手动调用装箱和拆箱方法。

当需要将基本数据类型赋值给包装类型、将包装类型赋值给基本数据类型、或者将包装类型参与运算时，Java 编译器会自动调用装箱和拆箱方法完成转换操作。具体原理如下：

1. 自动装箱：当需要将基本数据类型赋值给对应的包装类型时，编译器会自动调用 valueOf() 方法进行装箱。例如：

   ```java
   int a = 10;
   Integer b = a; // 自动装箱
   ```

   在这里，基本数据类型的变量 a 被赋值给了 Integer 类型的变量 b，编译器实际上会自动将 a 转换为 Integer 对象，相当于调用了 `Integer.valueOf(a)` 方法。

2. 自动拆箱：当需要将包装类型赋值给对应的基本数据类型时，编译器会自动调用 xxxValue() 方法进行拆箱。例如：

   ```java
   Integer a = new Integer(10);
   int b = a; // 自动拆箱
   ```

   在这里，Integer 类型的对象 a 被赋值给了基本数据类型的变量 b，编译器实际上会自动将 a 转换为 int 类型，相当于调用了 `a.intValue()` 方法。

3. 自动拆箱和装箱在运算中的表现：

   在包装类型参与运算时，会先自动进行拆箱操作，然后再对基本数据类型进行运算，最后再自动进行装箱操作。例如：

   ```java
   Integer a = 10;
   Integer b = 20;
   Integer c = a + b; // 自动拆箱和装箱
   ```

   在这里，变量 a 和 b 都是 Integer 类型的对象，它们分别被赋值为 10 和 20。在进行加法运算时，编译器会先自动将 a 和 b 拆箱为基本数据类型，然后进行加法运算得到结果 30，最后再自动将结果 30 装箱为 Integer 类型的对象，赋值给变量 c。

需要注意的是，随着自动装箱和拆箱的频繁使用，可能会导致性能问题。因为装箱过程需要创建新的对象，而拆箱过程需要调用方法，这些操作都会产生额外的开销。因此，在一些高性能要求的场景下，建议手动使用基本数据类型，以避免这种不必要的开销。

## 为什么浮点数运算的时候会有精度丢失的风险？

在计算机中，浮点数的存储和运算是以二进制形式进行的，但有些十进制小数无法精确地转换成有限长度的二进制小数，这就导致了浮点数在运算过程中可能会出现精度丢失问题。

例如，如果用二进制表示 0.1，会得到一个无限循环的二进制小数 0.0001100110011...，而计算机的内存空间有限，只能存储有限位数的二进制小数，所以必然会对小数进行截断或四舍五入，从而导致精度丢失。

另外，浮点数的运算还会涉及到舍入误差、精度误差等问题。例如：

1. 舍入误差：浮点数在进行加减乘除等运算时，可能会因为尾数太长而产生舍入误差。例如，0.1 + 0.2 的结果应该是 0.3，但在计算机中可能会得到类似于 0.30000000000000004 这样略微偏离正确值的结果。

2. 精度误差：在某些情况下，即使两个浮点数看起来相等，它们也可能在比较时发生不相等的情况。这是因为采用 IEEE 754 标准表示浮点数时，存储小数位数是有限的，而计算过程中会涉及舍入等误差，这些误差可能在比较时被放大，从而导致两个看起来相等的浮点数产生了微小的差异。

为了避免精度丢失问题，可以采用 BigDecimal 类型进行高精度计算，也可以通过尽量不使用浮点数、避免比较浮点数的方式来规避这种问题。

## 如何解决浮点数运算的精度丢失问题？

浮点数运算的精度丢失问题可以通过以下两种方式进行解决：

1. 使用 BigDecimal 类型进行计算：BigDecimal 是 Java 提供的可以用来进行高精度计算的类。它可以准确地表示任意精度的浮点数，避免了浮点数运算过程中精度丢失的问题。例如：

   ```java
   BigDecimal a = new BigDecimal("0.1");
   BigDecimal b = new BigDecimal("0.2");
   BigDecimal c = a.add(b); // 精确计算 0.1 + 0.2
   System.out.println(c); // 输出 0.3
   ```

2. 判断浮点数差值是否小于某个阈值：在进行浮点数比较时，不要直接使用等于或不等于符号，而是应该判断两个浮点数之差的绝对值是否小于一个很小的阈值。这样做可以避免由于浮点数运算产生的舍入误差和精度误差而导致的比较不准确的问题。例如：

   ```java
   double a = 0.1;
   double b = 0.2;
   double c = 0.3;
   double eps = 1e-6; // 设定一个阈值
   if (Math.abs(a + b - c) < eps) {
       System.out.println("a + b = c");
   } else {
       System.out.println("a + b != c");
   }
   ```

无论使用哪种方式，对于浮点数精度问题都需要格外小心，特别是在对计算结果要求非常精确的场景下，应该尽可能避免使用浮点数，并选择适合的高精度计算方法。

## 超过 long 整型的数据应该如何表示？

当需要表示超过 long 整型范围的数据时，可以使用 Java 提供的 BigInteger 类型进行表示和计算。

BigInteger 类型是一个能够任意精度表示整数的类，它允许我们处理比 long 类型更大的整数，例如上百位或上千位的数字。由于 BigInteger 类型可以动态扩展内部存储， 所以不会因为数值太大而导致溢出和错误。

以下是一个使用 BigInteger 类型的例子：

```java
import java.math.BigInteger;

public class BigIntegerExample {
    public static void main(String[] args) {
        // 创建两个 BigInteger 对象
        BigInteger a = new BigInteger("12345678901234567890");
        BigInteger b = new BigInteger("98765432109876543210");

        // 加法、减法、乘法、除法和取余运算
        BigInteger sum = a.add(b);
        BigInteger difference = a.subtract(b);
        BigInteger product = a.multiply(b);
        BigInteger quotient = a.divide(b);
        BigInteger remainder = a.remainder(b);

        System.out.println("a + b = " + sum);
        System.out.println("a - b = " + difference);
        System.out.println("a * b = " + product);
        System.out.println("a / b = " + quotient);
        System.out.println("a % b = " + remainder);
    }
}
```

运行结果如下：

```
a + b = 111111111011111111100
a - b = -86419753208641975320
a * b = 1219326311370217954770338291186857500
a / b = 0
a % b = 12345678901234567890
```

可以看到，使用 BigInteger 类型进行处理时可以准确地计算超过 long 整型范围的数字。但是需要注意的是，由于 BigInteger 类型的运算速度较慢，所以在实际应用中需要根据具体情况进行权衡和选择。

# 变量

## 成员变量与局部变量的区别？

成员变量和局部变量是Java中两种不同的变量类型，它们之间具有以下几个区别：

1. 定义位置不同：成员变量是定义在类中的变量，它们可以在整个类中被访问，而局部变量是定义在方法、代码块或形式参数中的变量，它们只能在相应的作用域内被访问。

2. 生命周期不同：成员变量的生命周期与对象的生命周期相同，即当对象创建时被初始化，在对象被销毁时被销毁。而局部变量的生命周期与它所在的方法或代码块的执行周期相同，当方法或代码块执行完毕后局部变量就会被销毁。

3. 默认值不同：成员变量有默认值，如果没有显式初始化，会被赋予默认值；局部变量没有默认值，必须在使用前进行初始化。

4. 访问权限不同：成员变量可以被类中的任何方法和该类的对象访问，其访问权限取决于它的修饰符；局部变量只能在定义它的代码块中被访问，其访问权限是局限于其所在的作用域的。

5. 存储位置不同：成员变量存储在堆内存中的对象中，局部变量存储在栈内存中的方法栈帧中。

需要注意的是，成员变量和局部变量虽然有很多不同点，但是它们都是变量，具有命名规则、数据类型等基本特性。在实际编程中，我们需要根据变量的作用域、生命周期以及访问权限等因素选择适当的变量类型。

## 静态变量有什么作用？

静态变量（也称为类变量）是指在类中所有对象共享的变量，它们可以通过类名来访问，在内存中只会有一份拷贝，所有对象都指向同一个内存地址。静态变量通常用 static 关键字修饰。

静态变量有以下几个作用：

1. 全局变量：静态变量定义在类中，可以被该类的所有对象共享，可以实现数据在多个对象之间的共享和传递，方便数据的操作和管理。

2. 节约内存：静态变量只需要在内存中保存一份拷贝，就可以被多个对象共享，避免了每次创建新对象时都需要分配内存的开销，从而节省了内存空间。

3. 程序优化：静态变量在整个类中都可访问，可以方便地进行统计、计数和累加等操作，同时避免了在方法中频繁创建局部变量的浪费。

4. 提供公共常量：将某些常用的值定义为静态变量，可以方便地通过类名来访问和使用，提高了代码的可读性和可维护性。

需要注意的是，静态变量的生命周期与类相同，它们在程序运行期间一直存在，除非被显式地赋值为 null 或程序运行结束。同时，静态变量与对象无关，不能通过 this 关键字来访问，而是需要通过类名来访问。

## 字符型常量和字符串常量的区别?

字符型常量和字符串常量都是 Java 中的常量，它们之间有着以下几个区别：

1. 数据类型不同：字符型常量是 char 类型的常量，表示单个字符，而字符串常量是 String 类型的常量，表示由多个字符组成的字符串。

2. 表示形式不同：字符型常量用单引号 '' 括起来表示，例如 'A'、'b' 等；字符串常量用双引号 "" 括起来表示，例如 "hello"、"Java" 等。

3. 存储方式不同：字符型常量只需要占用一个字节的内存空间，而字符串常量占用的内存空间则取决于字符串的长度。

4. 转义符使用不同：在字符串中可以使用转义符（\）来表示一些特殊字符，例如换行符 \n、制表符 \t 等，但在字符型常量中不能使用这些转义符，而是需要使用 Unicode 编码来表示。

需要注意的是，在 Java 中，字符型变量和字符型常量可以直接运算，而字符串变量和字符串常量需要使用字符串操作符 + 来实现连接。

例如：

```
char c = 'A';
System.out.println(c); // 输出 A

String s = "hello";
System.out.println(s); // 输出 hello

String s1 = "hello";
String s2 = "world";
System.out.println(s1 + s2); // 输出 helloworld
```

# 方法

## 什么是方法的返回值?方法有哪几种类型？

方法的返回值是指方法执行完毕后，返回给调用者的值。在 Java 中，方法的返回值类型需要在定义方法时指定，可以使用基本数据类型和引用数据类型作为返回值类型。

Java 中的方法返回值类型有以下几种：

1. void：表示没有返回值，即方法执行完毕后不返回任何值。

2. 基本数据类型：包括 byte、short、int、long、float、double 和 char 等，用来表示方法执行完毕后返回的基本数据类型的值。

3. 引用数据类型：包括类、数组等，用来表示方法执行完毕后返回的引用数据类型的对象。

需要注意的是，方法只能返回一个值，如果需要返回多个值，可以考虑使用数组、集合或自定义对象来封装返回值后再返回。

例如，下面的代码定义了一个求两数之和的方法 add，返回值类型为 int：

```
public int add(int num1, int num2) {
    return num1 + num2;
}
```

当该方法被调用时，它会接收两个 int 类型的参数，并返回它们的和作为方法的返回值。在调用该方法时，可以将返回值赋值给一个变量，也可以直接打印方法的返回值。

```
int sum = add(1, 2);
System.out.println(sum); // 输出 3

System.out.println(add(3,4)); // 输出 7
```

## 静态方法为什么不能调用非静态成员?

在 Java 中，静态方法是属于类的，而非静态成员是属于对象的。因为静态方法在对象创建之前就已经加载了，所以在静态方法中无法访问实例变量或实例方法，也就是无法直接调用非静态成员。

如果在静态方法中需要使用非静态成员，可以通过创建对象来访问这些成员，或者将这些成员设为静态的。

例如：

```
public class MyClass {
    private int num;
    public static void staticMethod() {
        // 不能访问非静态成员
        // System.out.println(num); // 编译报错

        // 可以通过创建对象来访问非静态成员
        MyClass obj = new MyClass();
        System.out.println(obj.num);

        // 或者将非静态成员设为静态的
        // private static int num;
    }
}
```

需要注意的是，静态方法只能调用静态成员，而非静态方法既可以访问静态成员，也可以访问非静态成员。因为非静态方法是在对象创建之后才会执行的，所以可以通过 this 关键字来访问非静态成员。

## 静态方法和实例方法有何不同？

静态方法和实例方法在 Java 中有以下几个不同点：

1. 调用方式不同：静态方法属于类，可以通过类名直接调用；而实例方法属于对象，必须通过对象引用来调用。

2. 访问权限不同：静态方法只能访问类的静态成员；而实例方法既可以访问类的静态成员，也可以访问实例成员。

3. 存储方式不同：静态方法存储在方法区中，而实例方法存储在堆中的对象内部。

4. 生命周期不同：静态方法在类加载时就已经存在，即使没有创建对象也可以调用；而实例方法必须在对象创建之后才能调用。

需要注意的是，由于静态方法不依赖于实例，所以在静态方法中不能使用 this 关键字，也无法访问非静态的实例成员。而在实例方法中可以使用 this 关键字来访问当前对象的成员，并且可以在方法内部直接使用非静态的实例成员。

例如：

```
public class MyClass {
    private static int a;
    private int b;

    public static void staticMethod() {
        // 只能访问静态成员 a
        System.out.println(a);

        // 不能访问非静态成员 b
        // System.out.println(b); // 编译报错
    }

    public void instanceMethod() {
        // 可以访问静态成员 a
        System.out.println(a);

        // 可以访问非静态成员 b，使用 this 关键字访问
        System.out.println(this.b);
    }
}
```

需要根据具体的应用场景来选择使用静态方法还是实例方法。如果某个方法不依赖于对象的状态，并且可以作为类的工具方法使用，那么可以将其定义为静态方法；而如果某个方法需要访问对象的状态，并且对每个对象的状态可能有所不同，那么应该将其定义为实例方法。

## 重载和重写有什么区别？

重载(Overloading)和重写(Overriding)是 Java 中面向对象编程中的两个重要概念。它们之间的区别在于：

1. 定义不同：重载是在同一个类中使用相同的方法名，但是参数列表不同，以实现不同的功能；而重写是子类重新定义父类中已经存在的方法。

2. 参数列表不同：重载方法的参数列表必须不同（个数、类型或顺序不同），但是返回值可以相同或不同；而重写方法与父类方法有相同的方法名、参数列表和返回值类型。

3. 调用方式不同：重载方法根据参数列表的不同进行匹配调用，由编译器决定调用哪个方法；而重写方法根据对象的实际类型来确定调用哪个方法，由虚拟机决定调用哪个方法。

需要注意的是，在重载中，方法的返回值类型和访问修饰符不起作用；而在重写中，方法的返回值类型必须与父类方法相同或是其子类，访问修饰符不能更加严格（即不能缩小范围）。

例如：

```
public class Animal {
    public void move() {
        System.out.println("动物可以移动");
    }
}

public class Dog extends Animal {
    public void move() {
        System.out.println("狗可以跑和走");
    }

    public void move(int distance) {
        System.out.println("狗可以移动" + distance + "米");
    }
}

public class Test {
    public static void main(String args[]) {
        Animal a = new Animal(); // Animal 对象
        Animal b = new Dog(); // Dog 对象

        a.move(); // 执行 Animal 类的方法
        b.move(); // 执行 Dog 类的方法
        // b.move(10); // 编译错误，Animal 类没有 move(int) 方法
        ((Dog)b).move(10); // 可以通过强制类型转换调用子类特有的重载方法
    }
}
```

在上面的代码中，Animal 类中有一个 move() 方法，而 Dog 类继承了该方法并进行了重写。Dog 类还新增了一个带参数的 move() 方法，实现了对父类方法的重载。在 main 方法中，分别创建了 Animal 对象和 Dog 对象，并调用它们的 move 方法，结果会根据对象实际类型而执行不同的方法。需要注意的是，在使用 Dog 对象调用重载方法时，需要强制类型转换为 Dog 类型才能调用成功。

总结一下，重载和重写都是 Java 中面向对象编程中的概念，它们之间的区别在于：

1. 定义不同：重载是在同一个类中使用相同的方法名，但是参数列表不同，以实现不同的功能；而重写是子类重新定义父类中已经存在的方法。

2. 参数列表不同：重载方法的参数列表必须不同（个数、类型或顺序不同），但是返回值可以相同或不同；而重写方法与父类方法有相同的方法名、参数列表和返回值类型。

3. 调用方式不同：重载方法根据参数列表的不同进行匹配调用，由编译器决定调用哪个方法；而重写方法根据对象的实际类型来确定调用哪个方法，由虚拟机决定调用哪个方法。

需要注意的是，在重载中，方法的返回值类型和访问修饰符不起作用；而在重写中，方法的返回值类型必须与父类方法相同或是其子类，访问修饰符不能更加严格（即不能缩小范围）。

在实际开发中，我们需要根据具体的需求来选择使用重载还是重写，以达到对程序性能和可读性的最优化。

## 什么是可变长参数？

可变长参数，也叫做不定长参数，是 Java 1.5 引入的一个新特性。它允许在方法声明中使用一个带有可变个数的参数列表，以方便地处理不定数量的参数。

在使用可变长参数时，需要在参数类型后面加上省略号(...)，来表示该参数可以接受任意长度的参数列表。在方法内部，我们可以像访问数组一样来访问这些参数。

例如，下面是一个使用可变长参数的方法：

```
public static void printNumbers(int... numbers) {
    System.out.print("Numbers: ");
    for (int number : numbers) {
        System.out.print(number + " ");
    }
    System.out.println();
}
```

该方法可以接受任意数量的 int 类型参数，并使用 for 循环来遍历这些参数，最终打印出这些数字。

使用该方法的示例代码如下：

```
printNumbers(1, 2, 3);
printNumbers(4, 5, 6, 7, 8);
```

输出结果为：

```
Numbers: 1 2 3 
Numbers: 4 5 6 7 8 
```

需要注意的是，可变长参数必须是方法的最后一个参数。在调用可变长参数的方法时，我们可以传递一个空数组作为参数，来表示没有传递任何值。

## 遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？

当调用一个方法时，Java 编译器会尝试寻找最匹配的方法。在方法重载的情况下，编译器会优先匹配固定参数的方法，而不是可变参数的方法。

具体来说，当存在多个重载方法时，Java 编译器会按照以下规则进行匹配：

1. 如果方法签名完全匹配，则选择该方法。

2. 如果没有找到完全匹配的方法，但是存在能够匹配所有实参的可变长度形参，则选择该方法。

3. 如果存在多个可变长度形参的匹配方法，则选择最具体的方法（即实参类型与该方法形参个数相同的方法）。

4. 如果存在多个可变长度形参的匹配方法，且有多个最具体方法，则编译失败。

例如，我们有如下两个方法：

```
public static void printNumbers(int... numbers) {
    System.out.println("可变参数方法被调用");
}

public static void printNumbers(int a, int b) {
    System.out.println("固定参数方法被调用");
}
```

当我们调用 `printNumbers(1, 2)` 时，会输出 “固定参数方法被调用”，因为固定参数方法的匹配优先级高于可变参数方法。

当我们调用 `printNumbers(1, 2, 3)` 时，会输出 “可变参数方法被调用”，因为没有与三个参数完全匹配的方法，但可变参数方法能够匹配所有的实参。

需要注意的是，当同时存在多个固定参数方法或可变参数方法时，编译器会按照上述规则进行匹配，但是如果固定参数和可变参数混合使用，则可能会出现歧义，导致编译失败。因此，在设计方法时，应当避免出现这种情况。