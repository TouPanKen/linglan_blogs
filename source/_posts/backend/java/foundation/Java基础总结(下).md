---
title: Java基础总结(下)
link: backend-java-foundation-Java基础总结(下)
catalog: true
lang: cn
date: 2022-07-31 01:02:56 
tags:
- 后端
- Java基础
categories:
- [后端,Java,基础]
---

# 异常

## Exception 和 Error 有什么区别？

Exception 和 Error 都是 Java 中的异常类，它们的主要区别在于它们所代表的错误类型以及处理方式上。

Exception 通常用于表示程序可以继续执行的异常情况，它一般是由于程序使用不当、外部环境错误或意外情况等导致的，但并不是致命的或无法恢复的，程序可以通过捕获和处理这些异常来恢复正常执行。例如，空指针异常、文件未找到异常等。

Error 则通常用于表示程序无法继续执行的严重问题，它一般代表着系统级别的错误或资源耗尽等问题，这些错误大多数情况下是由于 JVM 或操作系统本身出现了无法恢复的问题导致的。与 Exception 不同，Error 不应该被程序直接捕获和处理，因为在发生 Error 的情况下，程序已经处于不稳定甚至崩溃的状态，无法再进行恢复。例如，内存溢出错误、线程死锁错误等。

因此，我们在程序中使用 try-catch 语句时，应该只捕获并处理那些预料中可能会出现的异常情况，对于无法处理的错误或异常，应该将其抛给 JVM 进行处理或记录日志，以便后续进行排查和修复。

## Checked Exception 和 Unchecked Exception 有什么区别？

Java 中的异常分为 Checked Exception 和 Unchecked Exception 两种类型。

Checked Exception 是指在代码编译期间就可以被检测到的异常，必须显式地被程序捕获和处理，否则程序将无法通过编译。Checked Exception 通常用于表示程序在运行时可能会出现外部错误或条件限制等情况，需要被程序显式地捕获和处理来保证程序的稳定性和正确性。例如，IOException、SQLException 等。

Unchecked Exception，也称为 Runtime Exception，是指在代码执行期间才会被检测到的异常，程序可以不用捕获和处理它们，但最好进行处理以防止程序崩溃。Unchecked Exception 通常用于表示程序本身出现了逻辑错误或内部问题，如空指针异常、除零异常等。

在实际开发中，Checked Exception 和 Unchecked Exception 的使用应该根据具体情况来决定。如果一个异常只有在特定条件下才会被抛出，而且可能影响程序的正常执行，那么应该将其定义为 Checked Exception；如果一个异常是由程序自身内部逻辑错误或未预料的情况引起的，而且可以通过改进代码避免它的抛出，那么应该将其定义为 Unchecked Exception。同时，对于 Unchecked Exception，程序员应该在代码中进行相应的预防措施，以防止程序崩溃。

## Throwable 类常用方法有哪些？

Throwable 是 Java 语言中所有错误或异常的父类，它提供了一些常用的方法来处理错误和异常。其中一些常用的方法包括：

1. getMessage()：获取当前异常的详细信息。

2. getCause()：获取导致当前异常的原因。

3. printStackTrace()：输出当前异常的堆栈跟踪信息。

4. getStackTrace()：获取当前异常的堆栈跟踪信息。

5. initCause(Throwable cause)：设置导致当前异常的原因。

6. fillInStackTrace()：重新填充当前异常的堆栈跟踪信息。

7. toString()：返回当前异常的字符串表示。

其中，printStackTrace() 是一个非常有用的方法，它可以将当前异常的堆栈跟踪信息输出到标准错误流（System.err）中，以帮助程序员快速进行异常排查和调试。而 getCause() 和 initCause(Throwable cause) 方法则常用于在程序中进行异常的传播和包装操作。

需要注意的是，在处理 Throwable 或其子类的异常时，应该谨慎地使用 initCause(Throwable cause) 方法，因为这可能会导致异常的原因信息被覆盖掉或变得模糊不清。比如，对于已经设置了原因信息的异常，最好不要再次设置新的原因信息。另外，fillInStackTrace() 方法虽然可以重新填充异常的堆栈跟踪信息，但它也会导致异常对象的创建和初始化代价较高，因此应该谨慎使用。

## try-catch-finally 如何使用？

try-catch-finally 是 Java 中用于处理异常的一种常见方式，它的基本结构如下：

``` Java
try {
    // 可能会抛出异常的代码
} catch (Exception e) {
    // 捕获并处理异常
} finally {
    // 无论是否发生异常都会执行的代码块
}
```

在 try 块中包含可能会抛出异常的代码，如果在执行该代码时发生了异常，那么就会跳转到相应的 catch 块中，捕获并处理该异常。在 catch 块中，程序员可以对异常进行相应的处理，比如打印日志、提示用户等。

在 finally 块中，包含的代码无论在 try 块中是否发生异常都要执行，通常用于释放资源或进行清理操作，比如关闭数据库连接、关闭文件输入输出流等。

需要注意的是，finally 块中的代码一定会被执行，而且会在 catch 块中的代码执行完毕后再执行，即使 catch 块中有 return 语句也不例外。此外，如果 try 块中的代码抛出了异常，但是该异常被 catch 块捕获并处理了，那么程序会继续往下执行，直到 finally 块的代码执行完毕才返回到调用方。

try-catch-finally 结构是 Java 中异常处理的一种基本模式，可以有效地避免程序因为异常而崩溃或产生不可预料的错误。在使用时，应该根据具体情况选择合适的异常类型和处理方式，以保证程序的正确性和稳定性。

## finally 中的代码一定会执行吗？

是的，在 Java 中，finally 中的代码一定会执行，无论是否发生异常以及是否捕获和处理了异常，finally 中的代码块都会被执行。这是由 Java 的异常处理机制所决定的。finally 块主要用于释放资源、关闭 IO 流、清理临时文件等操作，确保程序的正确性和稳定性。

需要注意的是，在 try 块中的代码抛出异常时，catch 块也可能抛出新的异常或重新抛出同一个异常，因此 finally 块最好不要包含可能会抛出异常的代码。如果在 finally 块中发生了新的异常，那么该异常会覆盖原有的异常信息，导致原有异常信息丢失，从而使程序的调试和排查变得更加困难。

另外，还需要注意的是，如果在 finally 块中使用了 return 语句，那么它会覆盖 try 和 catch 块中的任何 return 语句，并将 finally 块的返回值返回给调用方。因此，如果需要在 finally 块中使用 return 语句，应该考虑其可能对程序逻辑产生的影响，以确保程序的正确性和可维护性。

## 如何使用 try-with-resources 代替try-catch-finally？

Java 7 引入的 try-with-resources 语句可以用来代替传统的 try-catch-finally 语句来管理资源，从而简化异常处理和资源管理的代码。它的基本结构如下：

``` Java
try (resource-1; resource-2; ...) {
    // 可能会抛出异常的代码
} catch (Exception e) {
    // 捕获并处理异常
}
```

在 try 语句中，可以跟多个需要在程序结束后关闭的资源对象。这些资源对象必须实现了 java.lang.AutoCloseable 接口或 java.io.Closeable 接口，并且可以在 try 语句中自动关闭，无需显式的调用 close() 方法。

当 try 语句执行完毕或在其中抛出异常时，系统会自动调用每个资源对象的 close() 方法来释放资源，而不需要显式地写 finally 块来关闭资源。这样可以简化代码，减少代码中的样板代码，提高代码的可读性和可维护性。

需要注意的是，使用 try-with-resources 来管理资源时，变量必须在 try 语句中声明和初始化，否则会导致编译错误。在 try 语句结束后，资源对象的作用域将结束，它们将不再可见，不能被引用。所以，如果需要在 try 之外访问资源对象，可以在声明时定义一个新的变量，再在 try-with-resources 语句中使用该变量。

总之，使用 try-with-resources 可以使程序更加简洁、安全和可读性，从而提高开发效率和代码质量。

## 异常使用有哪些需要注意的地方？

在 Java 程序中，异常处理是一种重要的编程技术，可以有效地处理程序运行过程中出现的各种错误和异常情况。但是，在使用异常处理时，我们需要注意以下几个方面：

1. 异常分类和处理：Java 中的异常分为受检查异常（checked exceptions）和非受检查异常（unchecked exceptions）。对于受检查异常，必须通过 try-catch 语句或者在方法签名中声明 throws 来处理。而对于非受检查异常，比如运行时异常（RuntimeException）、错误（Error）等，通常不需要显式处理。程序员需要根据具体情况选择正确的异常处理方式，以保证程序的健壮性和可维护性。

2. 异常捕获的粒度：异常捕获的粒度应该尽可能小，即捕获尽可能具体的异常类型。这样可以使异常处理更加精确，避免不必要的异常处理或错误处理，提高程序的正常运行效率。

3. 异常信息的处理和记录：对于捕获的异常，程序员应该处理和记录异常信息，以便快速地发现和解决问题。通常可以使用日志记录工具如 log4j、java.util.logging 等记录异常信息，并在程序中输出相应的日志信息。同时，对于用户操作错误等异常情况，程序员可以在前端界面的提示框中显示相应的异常信息，从而避免用户的不必要疑惑和困惑。

4. 异常恢复和程序终止：在处理异常时，程序员需要考虑如何恢复程序运行状态或者直接终止程序运行。对于某些严重的异常情况，比如内存溢出、文件系统错误等，可能导致程序无法正常运行，此时可以通过抛出非受检查异常或退出程序来终止程序的运行。对于一些可以容忍的异常情况，程序员可以根据具体情况进行恢复操作，以保证程序的正常运行。

总之，在使用异常处理时，程序员需要了解异常分类、粒度、信息处理和恢复机制等基本概念和技术，以保证程序的健壮性和可维护性。

# 泛型

## 什么是泛型？有什么作用？

泛型是 Java 5 引入的一种特性，它允许在定义类、接口和方法时使用类型参数（type parameter）来代替实际类型，从而使代码更加通用、灵活和安全。

用泛型编写的代码具有以下几个优点：

1. 类型安全：通过泛型，我们可以在编译时检查类型信息，避免了编译器无法发现的类型转换错误。这样可以提高代码的可靠性、稳定性和安全性。同时，泛型还可以使代码更加易懂、易于维护和扩展。

2. 代码重用：通过泛型，我们可以编写更加通用的代码，使其适用于多种数据类型，从而提高代码的重用率和效率。

3. 简化代码：泛型可以避免冗长的类型转换，使代码更加简洁和清晰。同时，使用泛型可以减少代码中的冗余和重复部分，从而提高代码的复用性和可读性。

Java 中的泛型主要包括泛型类、泛型接口、泛型方法和通配符（wildcard）类型等。泛型保证了代码的类型安全和灵活性，是 Java 编程中不可或缺的一部分。

## 泛型的使用方式有哪几种？

泛型在 Java 中有三种常见的使用方式，分别是：

1. 泛型类：泛型类指的是定义了一个或多个泛型类型参数的类。例如，List<T> 就是一个泛型类，其中的 T 是一个类型参数，它可以代表任意一种 Java 类型。通过泛型类，我们可以在编译时检查数据类型，并完成类型转换等操作。

2. 泛型接口：泛型接口指的是定义了一个或多个泛型类型参数的接口。与泛型类类似，泛型接口也可以在编译时检查数据类型，并完成类型转换。通常情况下，泛型接口用于定义一组抽象的数据结构和算法，同时也可以用于实现对象的序列化、反序列化等操作。

3. 泛型方法：泛型方法指的是在方法中定义一个或多个泛型类型参数，并在方法体中使用这些类型参数来操作数据。例如，Collections.sort(List<T>) 就是一个泛型方法，它可以对任意一种 List<T> 类型进行排序操作。通过泛型方法，我们可以更加灵活地操作数据，同时也可以避免类型转换错误和代码冗余问题。

以上三种方式都是泛型的常见使用方式，在实际开发中可以根据具体需求来选择合适的方式。

## 项目中哪里用到了泛型？

在项目中，泛型通常被广泛应用在集合类、数据结构和算法等方面。例如，在 Java 中的集合框架中，List、Set、Map 等接口和它们的实现类都使用了泛型类型参数，以便存储和操作不同类型的数据。具体来说，我们可以通过以下方式使用泛型：

1. 声明泛型集合类或接口：例如，声明一个 List<Integer> 类型的变量，其中 Integer 是一个泛型类型参数，表示 List 中只能存储整数类型的数据。

2. 定义泛型方法：例如，定义一个泛型方法 sort(List<T> list)，其中 T 是一个泛型类型参数，表示对 List 中的任意一种类型进行排序操作。

3. 使用通配符类型（wildcards）：例如，使用 ? 表示任意类型、使用 extends 表示上限、使用 super 表示下限等。这样可以使泛型类型变得更加灵活和通用。

在实际项目中，我们可以根据需求和场景选择合适的泛型方式，以提高代码的重用性、可读性和可维护性。

# 反射

## 什么是反射？

反射（Reflection）是 Java 的一种高级特性，它允许我们在运行时获取类的信息、创建对象、调用方法、访问属性等，而无需在编译时确定具体的类和方法。

Java 中的反射主要涉及以下几个核心类或接口：

1. Class 类：表示一个 Java 类，可以使用 Class.forName("className") 或 getClass() 等方法获取该类的 Class 对象。

2. Constructor 类：表示一个类的构造方法，可以使用 getConstructor(Class<?>... parameterTypes) 方法获取指定参数类型的构造方法，并使用 newInstance(Object... initargs) 方法创建该类的实例。

3. Method 类：表示一个类中的方法，可以使用 getMethod(String name, Class<?>... parameterTypes) 方法获取指定名称和参数类型的公共方法，并使用 invoke(Object obj, Object... args) 方法调用该方法。

4. Field 类：表示一个类中的字段，可以使用 getField(String name) 方法获取指定名称的公共字段，并使用 get(Object obj) 和 set(Object obj, Object value) 方法读取和修改该字段的值。

通过反射，我们可以灵活地操作类的属性和方法，动态地加载类和创建对象，并且可以实现一些特殊的功能，如动态代理、注解处理、代码生成、模板引擎等。反射是 Java 开发中非常重要的一部分，也是一种高级编程技巧，需要我们掌握其基本原理和常用方法。

## 反射的优缺点？

反射是 Java 中的一项高级特性，它具有以下优点和缺点：

优点：
1. 动态性：反射允许我们在运行时动态地获取类信息、创建对象、调用方法和访问属性等，使得程序更加灵活和动态。

2. 通用性：反射可以处理任意类型的对象，而不需要关心其具体类型。这使得它在一些通用框架和工具中得到广泛应用，如 ORM、依赖注入、序列化、模板引擎等。

3. 扩展性：反射可以轻松扩展已有的代码和系统，并且可以为框架和组件提供更加通用、灵活和可扩展的接口和实现方式。

缺点：
1. 性能开销：由于反射需要在运行时进行类型检查和方法调用，所以相比于静态方法调用和字段访问，它会带来一定的性能开销。

2. 安全性问题：反射使得我们可以绕过访问控制权限，以及在运行时修改、删除、新增类等操作，可能会导致一些安全性问题。

3. 可读性差：由于反射是一种非常灵活的技术，因此会使代码变得更加复杂和难以阅读。同时，由于编译器无法检查反射的类型和方法调用等，因此容易引入一些错误和隐患。

综上所述，反射是一项非常强大和灵活的技术，但是它也带来了一些性能、安全性和可读性的问题，我们需要在实际开发中根据具体场景和需求来权衡其利弊。

## 反射的应用场景？

反射是 Java 中的一项高级特性，它在很多场景下都得到了广泛的应用，如下所示：

1. 动态加载类和模块：反射可以在运行时动态地加载类和模块，以实现插件化、动态代理、动态生成代码等功能。

2. 注解处理：反射可以读取和处理注解，以实现一些自定义的功能或框架。

3. 实现 ORM 框架：反射可以读取和设置对象的属性值，以实现对象关系映射（ORM）框架。

4. 实现依赖注入：反射可以读取和设置对象的属性值，以实现依赖注入（DI）框架。

5. 实现序列化和反序列化：反射可以读取和设置对象的属性值，以实现对象的序列化和反序列化。

6. 编写通用工具库：反射可以处理任意类型的对象，可以为通用工具库提供更加通用和灵活的接口和实现方式。

总之，反射是一种非常灵活和强大的技术，可以为我们提供很多编程的便利性和创造力。但由于反射操作具有一定的开销和安全风险，因此在实际应用中需要谨慎使用并做好相应的安全和性能优化。

# 注解

## 什么是注解？

注解是 Java 编程语言中的一种特殊语法，它可以用来为程序的元素（类、方法、字段等）添加元数据信息。注解通过在源代码中以 @annotationName 的形式出现，可以帮助编译器和运行时环境对程序进行更加精确的控制和管理。

注解本质上是一种接口，定义了一组元数据成员变量，可以为这些变量设置默认值，并且可以限制注解的使用范围和生命周期。在编译器和运行时环境中，注解被解析为相应的 Java 对象，可以通过反射机制读取和处理注解信息。

注解的作用：

1. 提供元数据：注解可以为程序的元素添加额外的元数据信息，如作者、版本号、创建时间、参数验证等，以便于编译器、IDE 和其他工具进行更精确的推断和检查。

2. 规范约束：注解可以限制程序的使用范围、生命周期和其他行为，从而提高程序的可靠性、稳定性和安全性。

3. 自动生成代码：注解可以用来生成代码、配置文件和文档等，以方便程序员的开发和维护工作。

总之，注解是 Java 语言中的一项强大特性，可以为程序的元素添加额外的元数据信息，提高程序的可靠性、可读性和可维护性。在实际的编程中，注解被广泛应用于各种框架、库和工具中，如 Spring、JUnit、Hibernate 等，可以帮助我们更加方便地开发和管理Java程序。

## 注解的解析方法有哪几种？

在Java中解析注解主要有以下几种方法：

1. 编译时注解处理器：使用 Java 提供的 Annotation Processing Tool（APT）来处理注解，并在编译过程中生成新的源文件、类文件或其他文件。该方式最常用于生成代码、配置文件和文档等，如 Lombok 库就是基于编译时注解处理器实现的。

2. 运行时反射机制：使用 Java 反射机制来获取类、方法、字段等的注解信息，并进行相应的处理。该方式通常用于框架、库和工具中，如 Spring 框架就是通过运行时反射机制来实现依赖注入、AOP等功能的。

3. 字节码增强技术：使用 Java 字节码操作工具（如 ASM、Javassist 等）来修改字节码，以实现动态生成代理类、修改类的结构、替换方法或字段等。该方式最常用于字节码增强框架、类加载器、代码生成器等领域，如 AspectJ 就是一个典型的字节码增强框架。

总之，不同的注解解析方式都有其特点和适用场景，我们需要根据具体需求来选择合适的方式，并做好相应的安全和性能优化。

# SPI

## 什么是SPI?

SPI 全称为 Service Provider Interface，它是一种针对接口编程的技术，主要用于在扩展框架（如 Java 的 JDBC、Servlet、JAX-WS、JMS 等）中，为特定的接口寻找实现类。在 SPI 中，服务提供者通过标准接口向服务使用者提供一组实现，服务使用者则可以根据自身的需求，动态地选择和加载对应的实现类。

SPI 的实现原理比较简单，其核心思想就是在 META-INF/services/ 目录下创建一个以接口名称命名的文件，然后在文件中列出实现该接口的所有类名。当程序运行时，通过 Java 的类加载机制和反射机制，自动发现并加载这些实现类，并注入到相应的接口中，从而完成了对服务的扩展和定制。

SPI 的优点：

1. 松耦合：服务提供者和服务使用者之间解耦，灵活性更高。

2. 扩展性：支持动态加载和卸载服务，便于扩展和定制功能。

3. 可插拔：多个服务提供者之间相互独立，可以按需启用或禁用不同的服务实现。

4. 易于开发：SPI 模式可以简化开发过程，避免重复实现相同的功能。

总之，SPI 是一种非常实用和灵活的技术，可以为我们提供更加通用、可扩展和可定制化的框架和库。在实际应用中，SPI 被广泛运用于JDBC、Servlet、JAX-WS、JMS 等领域，以及一些流行的开源项目中，如Dubbo、Netty、Log4j2 等。

## SPI 和 API 有什么区别？

SPI（Service Provider Interface）和 API（Application Programming Interface）是两个不同的概念。

API 是指应用程序接口，它是一套规范或协议，用于描述软件组件之间的交互方式和数据格式。API 主要定义了一组类、方法、协议等，并规定了这些类、方法、协议的使用规则和限制。开发者可以根据 API 的规定来编写代码，并利用 API 中所提供的功能来实现自己的业务需求。

SPI 则是一种基于接口编程的机制，它是一种在运行时动态加载服务实现的机制。SPI 通常由两部分组成：服务接口和服务实现提供者。服务接口是被客户端调用的接口，而服务实现提供者则是动态装载到客户端中的实现类，可以有多个不同的实现类提供给客户端调用。

因此，从功能上来说，API 更加偏重于规范和约束，而 SPI 更加注重于扩展和定制。从实现上来说，API 静态固定，需要在编译期间确定所有的实现类；而 SPI 动态灵活，可以在运行时动态加载和替换实现类，实现更加灵活和可扩展的服务。

总之，SPI 和 API 都是非常重要的编程概念，但它们的应用场景和定位是不同的。在实际编程中，我们需要根据具体需求选择合适的机制，并遵循相应的设计原则和规范来开发可维护、可扩展和高效的程序。

## SPI 的缺点

1. 配置繁琐：SPI 机制需要在 META-INF/services/ 目录下创建以接口名称命名的文件，并且需要明确列出所有实现该接口的类名，这样才能被自动发现和加载。这样的配置过程比较繁琐，并且容易出现手误等问题。

2. 可靠性难以保证：SPI 机制没有强制实施服务提供者的规范，对于每个服务提供者的具体实现，其质量和稳定性无法得到完全控制，容易因为第三方库不兼容或接口变更等原因导致程序运行错误。

3. 安全性不足：SPI 机制的服务实现可以在运行时动态加载和卸载，如果没有正确限制其访问权限，则容易受到恶意攻击或非法使用。

总之，SPI 机制是一种灵活、可扩展、可插拔的编程机制，它可以大大简化程序的开发和维护，但也需要开发者谨慎使用，注意安全和可靠性问题。

# 序列化和反序列化

## 什么是序列化?什么是反序列化?

序列化是指将对象转换成二进制字节序列的过程，以便于在网络传输或数据存储中进行传输和持久化。序列化的结果是一个包含了原始对象的所有信息的二进制数据流，可以在需要时将其反序列化还原成原始对象。

反序列化则是指将已经序列化的二进制数据流转换成原始对象的过程，使得程序可以重新恢复原始对象的状态和属性。反序列化的过程与序列化相反，它将二进制数据流还原成原有的对象，并将其重新加载到内存中，使之成为可用的对象。

Java 中的序列化机制是指将 Java 对象转换成一组字节序列，从而可以方便地进行传输、存储或复制。Java 序列化支持对象的所有属性和方法，以及对象之间的关系，可以将整个对象图保存到文件或传输给其他进程。Java 反序列化则是将序列化后的字节序列重新转换成原始的 Java 对象，以便进行读取、操作或显示。

总之，序列化和反序列化是一种非常重要的编程概念，它们可以帮助我们实现数据的传输、存储和复制等功能，是编写高效可靠的分布式应用的必备技能之一。

## 如果有些字段不想进行序列化怎么办？

如果某些字段不想进行序列化，可以使用 Java 中的 transient 关键字进行标注。使用该关键字标记的字段不会被序列化，其值在序列化和反序列化过程中都会被忽略。

例如：

```java
public class Student implements Serializable {
    private String name;
    private int age;
    private transient String password; // 被 transient 标记的字段不会被序列化

    //...省略其他代码
}
```

在上述例子中，password 字段被 transient 关键字标记，因此在序列化和反序列化过程中将被忽略。

需要注意的是，如果要对某个类进行序列化，该类必须实现 Serializable 接口，否则将抛出 NotSerializableException 异常。同时，如果该类中包含引用其他对象的字段，则这些对象也必须是可序列化的，否则同样会导致序列化失败。因此，在实现序列化时需要仔细考虑每一个字段的序列化需求并进行适当标注。

总之，使用 transient 关键字可以方便地控制哪些字段需要被序列化，哪些字段不需要。这样可以保证序列化和反序列化过程的正确性和安全性。

## 常见序列化协议有哪些？

常见的序列化协议有如下几种：

1. Java 序列化：Java 序列化是一种基于 Java 平台的二进制编码格式，可以将 Java 对象转换成字节流，以便于在网络传输或存储时进行传输和持久化。Java 序列化支持对象的属性、方法、关系等信息，但序列化后的数据比较冗长，且只能被 Java 程序所识别。

2. JSON（JavaScript Object Notation）序列化：JSON 是一种轻量级的文本协议，可以将对象转换成字符串形式，在不同语言之间进行传输和解析。JSON 序列化具有可读性好、体积小、解析速度快等特点，广泛应用于 Web 开发、移动端开发、数据交换等场景。

3. XML（eXtensible Markup Language）序列化：XML 是一种可扩展的标记语言，可以将复杂的对象或数据结构转换成统一的文本格式，便于在不同系统之间进行数据交换和共享。XML 序列化具有语义清晰、可扩展性强等特点，但序列化后的数据比较冗长，解析速度也较慢。

4. Protobuf（Protocol Buffers）序列化：Protobuf 是一种由 Google 开发的高效二进制序列化协议，可以将结构化数据转换成紧凑的二进制格式，在存储和传输时占用更少的空间和带宽。Protobuf 序列化具有体积小、解析速度快、跨语言支持等特点，广泛应用于分布式系统、数据存储、通信协议等领域。

5. Thrift：Thrift 是一种由 Facebook 开源的类似 Protobuf 的跨语言通信框架，支持多种编程语言和多种通信协议，可以方便地进行 RPC 调用、消息传递、数据存储等操作。

总之，不同的序列化协议各有优缺点，应根据具体的业务需求选择合适的协议进行数据序列化和反序列化。

## 为什么不推荐使用 JDK 自带的序列化？

虽然 JDK 自带的序列化（Java Serialization）可以很方便地将对象转换为二进制流进行存储和传输，使用起来也比较简单，但是它存在一些缺点，不太适合在生产环境中直接使用，因此不推荐使用。

具体来说，JDK 自带的序列化存在以下几个问题：

1. 易受攻击：由于 JDK 自带的序列化机制使用字节码重组等技术对对象进行序列化和反序列化，这种方式容易受到恶意攻击，导致安全漏洞。

2. 性能问题：JDK 自带的序列化机制在序列化和反序列化过程中需要创建大量的临时对象，会造成频繁的内存分配和垃圾回收，从而降低系统性能。

3. 兼容性问题：由于 JDK 自带的序列化机制序列化后的数据包含了 Java 类信息，如果不同版本之间的 Java 类发生了变化，就会导致反序列化失败，进而影响应用程序的正常运行。

因此，为了解决这些问题，通常建议使用其他序列化框架，如 Protobuf、Thrift 等。这些框架都可以提供更好的性能、更加安全、更高效的序列化和反序列化方式，并且具有更好的跨语言支持，更适合在分布式系统等复杂场景中使用。


# I/O

## Java IO 流了解吗？

Java 中的 IO 流可以分为字节流和字符流两种类型，字节流操作的数据单位是 8 位字节，而字符流则操作的数据单位是 16 位字符。在实际开发中，我们需要根据数据类型的不同选用不同的流类型。

Java IO 流的操作分为输入和输出两种，输入流（InputStream）用于从外部读取数据，输出流（OutputStream）则用于向外部写入数据。同样，字符输入流（Reader）和字符输出流（Writer）都有类似的功能。

以下是一个简单的 Java IO 流示例：

```java
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class IODemo {
    public static void main(String[] args) {
        try {
            // 创建输入流
            FileInputStream input = new FileInputStream("input.txt");
            // 创建输出流
            FileOutputStream output = new FileOutputStream("output.txt");

            // 读取数据并写入到输出流
            byte[] buffer = new byte[1024];
            int len;
            while ((len = input.read(buffer)) != -1) {
                output.write(buffer, 0, len);
            }

            // 关闭流
            input.close();
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

在这个示例中，我们首先创建了一个输入流 FileInputStream 和一个输出流 FileOutputStream，然后使用 while 循环读取输入流中的数据，并写入到输出流中。最后，我们关闭了输入流和输出流。

总的来说，Java IO 流提供了一套强大且易于使用的 API，可以帮助我们方便地进行输入输出操作。但是需要注意的是，在使用 IO 流时需要非常小心，要正确处理异常和关闭流等问题，否则就可能会出现程序崩溃、数据丢失等情况。

## I/O 流为什么要分为字节流和字符流呢?

I/O 流分为字节流和字符流，是因为不同的应用场景和数据类型需要使用不同的流来进行处理。

首先，字节流主要用于操作二进制数据，其读写单位是字节（byte），因此比较适合于处理图片、音频、视频等数据，而字符流则主要用于操作文本数据，其读写单位为字符（char），可以方便地处理中文、日文等复杂字符集的数据。因为字符流提供了特殊的字符编码转换功能（如 UTF-8、GB2312 等），所以在处理文本数据时常常使用字符流。

其次，Java 中的字符类型是 16 位的 Unicode 编码，而字节流是以字节为单位进行读写的，因此在使用字节流读写字符数据时，需要考虑字符编码与字节编码之间的转换。如果在处理文本数据时错误地使用字节流，则可能会导致数据损坏、乱码等问题。

最后，在实际开发中，我们可以根据数据类型的不同选用不同的流类型，达到更好的效果。例如，当需要处理文本数据时，使用字符流可以更加方便地进行编码转换和字符处理；而在读取图片等二进制数据时，使用字节流可以更快地读取数据并进行处理。

总之，I/O 流分为字节流和字符流，是为了方便我们根据数据类型和应用场景来选择合适的流类型，并提高数据读写的效率和准确性。

## BIO、NIO 和 AIO 的区别？

BIO、NIO 和 AIO 是 Java 中用于网络编程的三种不同的 I/O 模型，它们在处理并发连接和数据时有着不同的特点和适用场景。

BIO（Blocking I/O）模型是最传统的 I/O 模型，称为阻塞式 I/O，其基本特征是采用一个独立线程来处理每个客户端连接，也就是常说的“一请求一应答”模型。当一个客户端连接到服务器时，服务器会创建一个新的线程来处理该连接，直到该连接关闭后线程才能被释放。BIO 模型的优点是代码简单易懂，易于理解和使用，但缺点是资源消耗过大，当并发连接数较高时会导致服务器性能急剧下降。

NIO（Non-blocking I/O）模型是非阻塞式 I/O，其主要特点是采用多路复用器（Selector）来处理多个连接，典型的实现方式包括 Select、Poll、Epoll 等。与 BIO 不同，NIO 的线程模型采用一个线程来处理多个连接，使得服务器的资源占用大大减少。NIO 模型的优点是处理并发连接的性能比 BIO 模型提高了一个量级，但缺点是代码相对比较复杂，因为要考虑事件驱动、选择器等方面的问题。

AIO（Asynchronous I/O）模型是异步式 I/O，其主要特点是采用异步处理方式（异步通道）来处理多个连接，异步通道是 NIO 2 的新增特性。AIO 模式相比于 NIO 模式更为高效，在高并发场景下能给服务器带来更好的性能。由于 AIO 模型采用异步处理方式，使得所有的 I/O 操作都是异步执行的，因此它具有非常高的并发能力和较低的延迟，但也因为这个原因，实现起来比较复杂。

综上所述，BIO、NIO 和 AIO 三种 I/O 模型各有优点和缺点，我们需要根据自己的需求来选择合适的模型。在并发连接数较小的情况下，可以考虑使用 BIO 模型；在并发连接数较大的情况下，可以考虑使用 NIO 模型；在对性能要求非常高的场景下，可以考虑使用 AIO 模型。

## Java IO 中的设计模式有哪些？

Java IO中常用的几种设计模式有以下几种：

1.装饰器模式(Decorator) : 装饰器模式是Java I/O中最为常见的一种设计模式，主要用于对输入输出流进行扩展。通过将输入输出流与过滤器和缓冲区结合，使得我们可以更加灵活地使用I/O流。

2.适配器模式(Adapter)：适配器模式也常用于Java I/O，它的作用是将原本不兼容的类或接口转换成符合要求的类或接口。在I/O中经常使用的是InputStreamReader 和 OutputStreamWriter来实现字符编码之间的转换。

3.工厂模式(Factory)：I/O重要的职责之一就是创建输入/输出对象，例如FileInputStream和FileOutputStream，RandomAccessFile等。这些类都是通过工厂方法设计模式创建的。

4.责任链模式(Chain of Responsibility)：责任链模式是指多个处理器依次对请求进行处理，如果当前处理器无法处理该请求，则传递给下一个处理器，直到找到能够处理该请求的处理器为止。在Java I/O中，我们可以使用FilterInputStream和FilterOutputStream 进行责任链构建。

5.策略模式(Strategy)：策略模式也用于Java I/O，主要用于封装不同的算法或策略。例如，在Java I/O中，不同的输入或输出类型都需要根据其特点采用不同的策略。

总之，在Java I/O中有很多不同的设计模式，这些模式可以实现I/O流的复杂操作和高效的数据处理。在实际开发中，我们需要根据不同的场景和需求选择合适的模式进行使用。

# 语法糖

## 什么是语法糖？

语法糖（Syntactic Sugar）通常指编程语言中一些简化代码书写的语法，这些语法并不会影响程序运行时的行为和结果，只是让程序员可以更加方便地书写和理解代码。

在Java中，有很多语法糖可以提高程序员的编码效率和代码可读性，例如：

1. 自动装箱和拆箱：在Java5之前，需要手动将基本类型和封装类型进行转换，而在Java5及以后的版本中，可以直接使用自动装箱和拆箱语法进行转换，如int和Integer之间的转换。

2. 增强for循环：增强for循环是Java5中引入的特性，它使得遍历数组、集合等数据结构变得更加简单明了，减少了代码冗余。

3. 可变参数：可变参数是Java5中新增的特性，允许我们在方法调用时传递可变数量的参数，使得方法的调用更加简化。

4. try-with-resources语句：try-with-resources语句是Java7中引入的特性，它可以自动释放资源，无需显式地调用close()方法。这样可以使程序更加简洁且可读性更高。

5. Lambda表达式：Lambda表达式是Java8中引入的特性，它可以使得代码更加简洁，提高代码的可读性和可维护性。

总之，语法糖是编程语言中的一种技术手段，用于简化代码书写和提高代码的可读性和可维护性，在Java中也有很多实例。

## Java 中有哪些常见的语法糖？

1. foreach 循环语法糖

foreach 循环语法糖也叫增强型 for 循环，它可以在循环中遍历一个数组或集合，代码更加简洁易读。

例如：

```java
String[] arr = {"apple", "banana", "orange"};
for(String fruit : arr){
    System.out.println(fruit);
}
```

2. 自动装箱和自动拆箱语法糖

Java 5 引入了自动装箱和自动拆箱语法糖，使得基本数据类型和其对应的包装类型之间可以相互转换，更加方便。

例如：

```java
int num = 10;
Integer integer = num; // 自动装箱
int newNum = integer; // 自动拆箱
```

3. 可变参数语法糖

可变参数语法糖可以让函数接受可变数量的参数，简化了代码编写。

例如：

```java
public void printNumbers(int... numbers){
    for(int num : numbers){
        System.out.println(num);
    }
}

printNumbers(1, 2, 3); // 输出：1 2 3
```

4. 泛型语法糖

泛型语法糖可以让我们在编写代码时指定一种通用类型，在运行时再确定具体类型，提高了代码的灵活性和安全性。

例如：

```java
List<String> list = new ArrayList<String>();
list.add("apple");
list.add("banana");
String str = list.get(0);
```

以上是 Java 中常见的一些语法糖的示例。